= Memory/VM on stblinux
Broadcom Corporation <support@broadcom.com>
v1.1, 2015-06-09: Updated for STB Linux 3.14-1.7 release
:toc:

== Reserved A/V memory (BMEM and/or CMA)

NOTE: This section was updated for STB Linux 3.14-1.7+ for
Brahma-B15-based SoCs, and some of the usage has changed compared to
BMEM on BMIPS.  Please be sure to refer to the documentation for the
STB Linux version you are using for the most accurate information.

The A/V peripherals (managed by the PI/Nexus middleware) require
large, contiguous memory regions.  There are two different reservation
schemes:

. dedicated reserved memory ("BMEM"), enabled by option
  CONFIG_BRCMSTB_BMEM.
. reserved memory using Contiguous Memory Allocator (CMA), enabled by
  option CONFIG_BRCMSTB_CMA.
  footnote:[Strictly speaking, the Broadcom STB CMA device is a user
  of CMA, and we create a dedicated device for refsw.  Other drivers
  also use CMA, so it would be more correct to say "the Broadcom STB
  CMA device".  For the sake of brevity, we will use "CMA" to refer to
  the Broadcom STB CMA device in this document.]

BMEM and CMA regions are set aside by the Linux kernel at boot time,
and intended to be managed entirely by PI/Nexus.  Linux provides the
following capabilities with respect to these reserved regions:

 * Allow the user to define the size and location of BMEM and CMA
   regions, subject to certain restrictions

 * Allow `O_DIRECT` I/O from SATA and USB storage devices, to and from
   the BMEM region, to facilitate zero-copy data transfers (typically
   video streaming / PVR).

 * Allow `mmap()` to these regions from user programs, and
   cached/uncached `ioremap()` to these regions from kernel drivers.

By default, all of HIGHMEM within the 32-bit address space on MEMC0,
MEMC1, and MEMC2 are set aside as BMEM.  Consult the hardware
documentation to get a comprehensive view of the system memory for
your chip and what memory will be in this default reservation.  This
default can be overridden with different regions or disabled by
providing options on the kernel boot command line.  See the following
table of examples to see how to set the desired memory reservations.

NOTE: Providing `bmem` or `brcm_cma` boot parameters will disable the
default reservation.

.BMEM and CMA kernel boot command line examples
[cols="1m,3"]
|==================================================================

| bmem=64M@512M |
Create a single BMEM region (bmem.0) at PA 0x2000_0000, length
0x0400_0000 (64MB).

| bmem=64M@512M bmem=128M@768M  |
Same as above, plus create a second BMEM region (bmem.1) at PA
0x3000_0000, length 0x0800_0000 (128MB).

| bmem=64M@0x20000000 bmem=128M@0x30000000 |
Same as above.  Sometimes it is easier to specify the physical
address directly.

| bmem=64M@512M brcm_cma=128M@768M |
Same as above, except that instead of the second reserved region
being BMEM, it will be CMA.

| [no options] |
The default behavior is to create a BMEM region ranging from 256MB
(0x1000_0000) up to the end of the first memory controller in the
32-bit address space, then create BMEM regions for all of the memory
on the other memory controllers.  For boards with memory above the
32-bit address range, the default is to have the first 64MB reserved
in those regions and to leave the rest for Linux.

| bmem=0 |
Disable BMEM.

| brcm_cma=0 |
Disable Broadcom CMA device.

|==================================================================

The application should read
`/sys/devices/platform/brcmstb/bmem.*` to determine which BMEM
regions have been created by the kernel.  Each `bmem.N` file
contains the start address and length, in hex, separated by a space.

To determine which CMA regions have been created by the kernel, the
application should use the ioctls listed in
`linux/include/uapi/linux/brcmstb/cma_driver.h`.  See
`rootfs/user/cmatool/cmatool.c` for an example.  Alternatively,
instead of using the ioctls directly, use the output of
`cmatool listall` to retrieve the information.

BMEM and CMA regions are all created at boot time and cannot be
altered later.

Futexes, mutexes, etc. *may not* be created in BMEM regions.  Linux
does not track this memory the same way as normal pages, and the results
will be undefined.

Applications must handle all cache coherency in the reserved regions.
On Brahma-B15 SoCs, this *cannot* be done with the `cacheflush()`
library function because that is MIPS-specific.  Note that the
cacheflush syscall on ARM also differs in semantics and will *not* do
the same thing as on MIPS.  One method of ensuring cache coherency on
a region would be to use the DMA API (see
linux/Documentation/DMA-API.txt) to map and unmap the region.

IMPORTANT: There is a good chunk of information on the web discussing
how to use the `__clear_cache()` function (gcc-specific?) to do a
cache flush on buffers mmap'd with `PROT_EXEC`.  However, most of
these are discussing how what is necessary for JIT to work.  On ARM,
the `__clear_cache()` function calls the private ARM `cacheflush()`
syscall (not the same as the MIPS `cacheflush()` syscall), which
cleans the data cache to the point of unification (PoU) and
invalidates the instruction cache.  This is sufficient for JIT.
However, for the likely STB use case of interacting with devices that
have their own view of memory, this is not enough: the data cache must
be cleaned to the point of coherence (PoC).

== Kernel memory maps and large memory

Broadcom Brahma-B15 chips (28nm) can generally address large amounts
of DRAM.  The memory maps differ across chip families, but generally
they have EBI/Flash from PA 0xE000_0000 - 0xEFFF_FFFF and registers
from PA 0xF000_0000 - 0xF1FF_FFFF.

HIGHMEM is the method that Linux uses to access larger amounts
of physical memory.  HIGHMEM works by creating temporary kernel
mappings to read or write upper memory.

All HIGHMEM configurations have SPARSEMEM enabled by default.
SPARSEMEM saves several megabytes of system memory by avoiding the
creation of page descriptor (`struct page`) arrays for address space
that falls into one of the memory holes.  The use of SPARSEMEM is
especially important to conserve memory for system configurations that
use the Large Physical Address Extension (LPAE) to access addresses
above the 32-bit range (up to 40-bits).

Note that "high memory", not being direct-mapped, can never be used
for `kmalloc()`, `skbuff` structures, etc.

== Cache coherency

On most MIPS and ARM implementations, cache coherency must be explicitly
handled by software.  On STB Linux, this generally means:

 * After writing instruction code to memory, the data cache (D$) must
   be flushed to write back the new instructions, then the instruction
   cache (I$) must be flushed so that it picks up the new code from
   memory or the L2.

 * In cases where cache aliases may be created, they need to be
   flushed out by the OS.  This problem affects systems with virtually
   indexed caches in which the page size is smaller than the way size.
   Broadcom Brahma-B15 CPUs have nonaliasing instruction and data caches.

 * Prior to a DMA operation, a D$ writeback/invalidate operation is
   performed on a range that covers the DMA buffer.  This ensures that
   dirty cache lines will not be written back during the DMA
   operation, and that stale data is purged from the cache so that the
   CPU sees the data written to the buffer by the device.

 * On processors with external second-level (L2) caches, such as the
   MIPS R34k, L2 cache lines will need to be manually flushed to
   maintain coherency during DMA operations.  On processors with
   integrated, exclusive L2 caches, such as BMIPS4380, this is not
   necessary.

=== Brahma-B15 (28nm ARMv7) cache notes

On Brahma-B15-based SoCs, the Read-Ahead Cache (RAC) is between the
B15 complex's L2 cache and DDR memory.  The stblinux kernel has
modifications to the cache maintenance functions so that they flush
the RAC contents when necessary.  For details, see
`linux/arch/arm/mm/cache-b15-rac.c` and `linux/arch/arm/mm/cache-v7.S`.

=== BMIPS cache notes

The cacheflush() system call implementation has been enhanced on
stblinux in order to provide finer-grained flushing to user-mode
applications.  The default MIPS implementation flushes the entire cache,
but often the middleware needs to flush a smaller range.

BMIPS3300, BMIPS4380, and MIPS R34k cores in the Broadcom STB chips all
exhibit cache aliases when using the standard 4kB page size.  For instance,
on BMIPS4380, the D$ is 64kB and 4-way, so the way size is 16kB.  As long
as the way size is larger than the page size, the OS will need to take
steps to prevent cache aliases.

BMIPS5000 does not have cache aliases.

More information is available in `stblinux-2.6.37/Documentation/cachetlb.txt` .

Bionic libc (Android) has a non-standard cacheflush implementation
which calls `__clear_cache()` instead of the `cacheflush()` syscall.
This should be avoided because it does not cause the proper flags to
be passed to the kernel.

== Multiple memory controllers

Numerous STB chipsets have more than one memory controller (MEMC0,
MEMC1, ...).  The way Linux handles this memory varies, depending on
the chip architecture:

1. On most existing non-UMA designs, MEMC1 (and MEMC2, ...) are not
even accessible by the CPU.  Therefore, it is clear that any DRAM on
MEMC1 will not be part of the Linux memory pool, and cannot be mapped
into the process address space.  It is completely off limits except
for use as an A/V buffer region by the PI.  Examples: 7400; 7405 in
non-UMA mode.

2. For chips that support UMA mode, all system memory is "symmetric"
from a software perspective and can be allocated to Linux or PI as the
user sees fit.  There are no restrictions on any region with regard to
use by Linux.  Examples: 7405 in UMA mode; 7468/7550 (single MEMC).

3. On some designs, MEMC1 and MEMC2 are accessible to the CPU but only
connected to the A/V clients.  They are *not* connected to Linux
peripherals like USB, GENET, SATA, MOCA, or EDU.  Example: 7420.
+
Due to this architectural limitation, it is not feasible to add this
memory to the Linux memory pool because the Linux drivers would not
know what to do if they were passed a pointer to DRAM that has no DMA
access.  Many common operations (such as PVR) assume zero-copy
transactions, and double-buffering is not an option.
+
However, it *is* possible to map regions from MEMC1 and MEMC2 into the
process address space using `mmap()`.  They can be read and written
from the CPU using cached or uncached (O_SYNC) accesses, but DMA
operations such as direct I/O are prohibited.

4. On other designs, MEMC1 and MEMC2 are accessible to the CPU and to
all of the Linux peripherals.  In cases like this, MEMC1 and MEMC2 can
be added to the Linux memory pool, and any BMEM or CMA regions of that
memory can be accessed through `mmap()`.  Example: 7425, Brahma-B15
SoCs such as 7445.

For case #3, `malloc()` and similar functions will only allocate RAM
from the Linux memory pool on MEMC0.  However, the application can
always map MEMC1 and MEMC2 directly.  This program demonstrates how to
write a simple allocator (`m1alloc()`) which uses MEMC1 instead of the
Linux memory pool:

.m1alloc_example.c
----
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>

#define MEMC1_START		0x60000000	/* for 7420 only */

static void *m1alloc(unsigned int len)
{
	static int fd = -1;
	static int page_size = 0;
	unsigned long addr, n_bytes;
	static void *free_ptr = (void *)MEMC1_START;

	if (fd == -1)
		fd = open("/dev/mem", O_RDWR);
	if (!page_size)
		page_size = getpagesize();
	n_bytes = ((len + page_size - 1) / page_size) * page_size;
	addr = (unsigned long)free_ptr;
	free_ptr += n_bytes;
	return mmap(NULL, n_bytes, (PROT_READ | PROT_WRITE | PROT_EXEC),
		MAP_SHARED, fd, addr);
}

int main(int argc, char **argv)
{
	void *a, *b, *c;

	a = m1alloc(4096);
	b = m1alloc(10000);
	c = m1alloc(1000);
	printf("Allocated memory at %p, %p, %p\n", a, b, c);
	return 0;
}
----

The application must ensure that the regions it uses do not
conflict with any regions in use by PI/Nexus or other processes/threads.
These regions may not be used for `O_DIRECT` I/O or any other
operation involving DMA to/from the Linux peripherals.

== Overcommit

The Linux kernel provides three options regarding memory overcommit.
These are covered in
`linux/Documentation/vm/overcommit-accounting` :

----
0	-	Heuristic overcommit handling. Obvious overcommits of
		address space are refused. Used for a typical system. It
		ensures a seriously wild allocation fails while allowing
		overcommit to reduce swap usage.  root is allowed to 
		allocate slighly more memory in this mode. This is the 
		default.

1	-	Always overcommit. Appropriate for some scientific
		applications.

2	-	Don't overcommit. The total address space commit
		for the system is not permitted to exceed swap + a
		configurable percentage (default is 50) of physical RAM.
		Depending on the percentage you use, in most situations
		this means a process will not be killed while accessing
		pages but will receive errors on memory allocation as
		appropriate.

The overcommit policy is set via the sysctl `vm.overcommit_memory'.

The overcommit percentage is set via `vm.overcommit_ratio'.
----

On most Linux systems, policy #0 (heuristic overcommit) is the
default.  However, many embedded programmers prefer policy #2 because
it is more deterministic and more closely resembles the behavior seen
on other embedded systems (or under an RTOS).

On Broadcom 2.6.18 kernels, policy #2 was the default unless swap was
enabled.  On Broadcom 2.6.31 and newer kernels, policy #0 is the
default.

When using policy #2, malloc() may return NULL even though there is
still unused memory in the system.  Some ways to deal with this
include:

 * Increase the overcommit ratio.
 * Change the per-process and/or per-thread stack size (see below).
 * Switch to policy #0.

When using policy #0, memory allocations may succeed even though there
is insufficient physical memory to satisfy all outstanding
allocations.  Physical memory is only requested when the memory is
actually written to.  Therefore, seemingly innocuous events that may
cause a fresh page to be dirtied (even pushing an extra word onto the
stack) could trigger an out-of-memory (OOM) event.

Sample commands for changing the overcommit policy and ratio:

----
# echo 0 > /proc/sys/vm/overcommit_memory
# echo 60 > /proc/sys/vm/overcommit_ratio
----

== Stacks

The default size for process/thread stacks under stblinux is 8MB.  In the
stblinux-2.6.18 kernel, this was reduced to 1MB.  On stblinux-2.6.31 and
newer, the default value is retained.  Therefore, if overcommit policy #2
is used, the default stack size should be reduced, as the entire 8MB would
be taken out of the physical memory pool for every process and thread
otherwise.

There are several ways to adjust the stack size:

 * For pthreads, use the _attr_ argument to pthread_create() to
   request a different stack size.
 * The `ulimit -s` command may also be used to adjust the stack
   allocated to the current process, and any children forked off
   afterward.
 * If `ulimit -s` is set to allow an unlimited stack size,
   pthread_create() will default to 2MB (which is the
   architecture-specific default for MIPS hard-coded in uClibc and
   (e)glibc--search for `ARCH_STACK_DEFAULT_SIZE`).
   Otherwise, uClibc will use the `ulimit -s` setting for thread
   stacks.

In the reference kernels, 8kB is allocated for the kernel stack and
for the thread/task info structures on each process.  It may be
possible to increase the kernel stack by modifying
`linux/arch/{arm,mips}/include/asm/thread_info.h` , although this is
not officially supported.

Sample code for adjusting the pthread stack size:

----
#include <pthread.h>;
#include <limits.h>;

pthread_t thread;
pthread_attr_t attr;

if(pthread_attr_init(&attr) != 0)
	return(FALSE);
if(pthread_attr_setstacksize(&attr, PTHREAD_STACK_MIN) != 0)
	return(FALSE);
if(pthread_create(&thread, &attr, start_routine, arg) != 0)
	return(FALSE);
----
