= NAND Flash FAQ
Broadcom Corporation <support@broadcom.com>
v1.0, 2015-04-20: Converted to asciidoc
:toc:
:numbered:
:stem:
:asciimath:
// Above, :asciimath: is for asciidoc, :stem: for asciidoctor

This FAQ describes many of the common pitfalls seen on our STB Linux
platforms with NAND (and other) flash. Some issues may be specific to
a particular kernel, so if you have any doubts, refer to the
documentation provided with your kernel.


[[cfe_rootfs]]
== Can BOLT write Linux rootfs images to the flash?

In general, no. For NAND, this would require moving GPLed BBT
management code into the non-GPL CFE (BOLT is based on CFE), which is
not permitted under the terms of the license. For anything based on
UBI (UBIFS on NOR/NAND, or SQUASHFS on NAND), the same concern applies
to the GPLed UBI code.

In addition, CFE was never designed to understand Linux filesystems,
and there is little reason to duplicate this functionality in BOLT
since it is already present in the kernel. There are many complexities
involved in duplicating this functionality. For more information:
http://www.linux-mtd.infradead.org/doc/ubi.html#L_flasher_algo[How UBI flasher should work].

In the above documentation, you might notice the "free space fixup"
workaround for UBIFS. Note that this workaround is not applicable to
some rootfs configurations, as it is UBIFS-only, whereas some systems
utilize SQUASHFS on top of UBI+gluebi for read-only rootfs.


[[part_map]]
== How do I change the MTD partition map?

By default, the MTD partition map is derived from the device tree (DT)
as determined by BOLT. There are at least two different ways of
customizing this map:

. Modify the rootfs/kernel partition boundaries through the BOLT
compile-time configuration. Please refer to the BOLT documentation
for more information.

. Use the `cmdlinepart` facility to specify the offset and size for
each partition on the kernel command line. Example:
+
----
boot HOST:PATH/vmlinuz-7425b0 "mtdparts=brcmnand.0:40M@16M(rootfs),4M(kernel),16M(app) $ROOTFS"
----
+
To specify the partition map for the first NAND device, use
`brcmnand.0`.  For the first NOR device, use `physmap-flash.0` . For
the first SPI device, use `spi0.0`.
+
Replace `$ROOTFS` with the appropriate root filesystem parameters; see
<<ubiroot,the ubiroot entry>> for more info.
+
Additional examples and documentation can be found in the comments in
`drivers/mtd/cmdlinepart.c`.


[[bbm]]
== What is a bad block marker?

A bad block marker (BBM) is a special pattern found in the out-of-band
(OOB) region of each eraseblock to denote factory-detected bad
blocks--and "worn out" bad blocks that may develop over time--in NAND
flash.  For example, many NAND manufacturers' datasheets define a bad
block marker as follows:

====
Any block, where the 1st byte in the spare area of the 1st page does not
contain FFh, is a bad block.
====

However, the exact BBM location tends to vary across different manufacturers
and even across different products from the same manufacturer. For example, the
pattern may be located in "the 1st or 2nd page" or "the last page" of each
block. Both BOLT and Linux must know this location in order to properly detect
factory-marked bad blocks and in order to consistently mark new ones as they
develop.


[[linux_badblocks]]
== How does Linux handle bad blocks?

Linux--particularly, the MTD/NAND subsystem--performs efficient bad
block handling by utilizing a bad block table (BBT). The BBT records the status
of every block on the NAND chip, yielding a "good" or "bad" status. This table
is built at boot-time (by scanning for factory-marked bad blocks as well as
marked "worn out" blocks) then stored in memory to provide fast lookup.

In the current Broadcom STB NAND driver (2.6.37 and newer), this table is also
replicated within the flash (a.k.a. "flash-based BBT") so that when Linux can
find a valid table on the flash, it does not have to rescan the entire chip for
bad blocks on every boot. The flash-based BBT configuration option is selected
by default due to significant performance benefits when used on large NAND
flash. For example, a rough timing measurement on a Micron 4GB MLC NAND shows
that a flash-based BBT can decrease NAND initialization time from 2.6 seconds to
about 0.3 seconds.

Flash-based BBT can be disabled entirely by removing the following NAND BBT
options from the driver (`drivers/mtd/nand/brcmstb_nand.c`):

`NAND_BBT_USE_FLASH`:: Store the bad block table in a designated area
of the flash. Enabled by default.
`NAND_BBT_NO_OOB`:: Do not use the OOB when storing the bad block
table identifier. Must be used with `NAND_BBT_USE_FLASH`.  Enabled by
default.


[[where_flash_bbt]]
== Where does Linux store its flash-based BBT?

Broadcom's reference kernel releases utilize a flash-based bad block
table (BBT) which is stored at the end of the NAND device. Linux
reserves the last four blocks of the device, using two of them for
storing mirrored copies of the BBT--the other two are reserved in case
one of the reserved blocks wears out. These blocks appear as bad
blocks to the system, so that Linux applications and filesystems
cannot accidentally erase them; however, they do not have (nor do they
require) any special marking outside of Linux and will appear as
normal blocks. Non-Linux applications (e.g., factory programmers)
should avoid placing crucial data in this region, as Linux will simply
erase the data in order to write a new BBT.

.BBT size calculation example
====
On a device with eraseblock size 512 kiB, Linux will reserve:
[asciimath]
++++
512\ "kiB" cdot 4\ "blocks" = 2\ "MiB"
++++
====

Note that this feature is different than in Broadcom's STB Linux
2.6.31, where the system required a special BBT partition.


[[reset_flash_bbt]]
== How can I reset the flash-based BBT?

Currently, the only supported way to reset the flash-based bad block
table is from outside of Linux, by erasing the BBT area (see
<<where_flash_bbt,Where does Linux store its flash-based BBT?>>).
In other words, you can discard the bad block table by erasing the
last 4 blocks of the device (or the entire flash) using a BOLT hack,
Broadband Studio, or <<Webflasher>> (if available). Once the
flash-based BBT is erased, Linux will rebuild the bad block table by
scanning the bad block markers found in each block's OOB region next
time it boots.


[[cfe_badblocks]]
== How does BOLT handle bad blocks?

To detect bad blocks in NAND, BOLT only checks the OOB of each block,
looking for a bad block marker. It does not understand Linux's bad
block table format, in part due to GPL license incompatibility.

WARNING: Newly-marked bad blocks from BOLT will not be included in
Linux's flash-based BBT.

Synchronizing BOLT's newly-marked bad blocks with Linux's BBT is
currently not simple. There are simpler kernel-related solutions in
the works, but for now you have the following options:

- <<linux_badblocks,disable Linux's flash-based BBT>>
- don't perform flash updates from BOLT (and hence, never mark bad
  blocks from BOLT)
- force BOLT to erase Linux's flash-based BBT every time it marks a
  new bad block (see <<reset_flash_bbt,How can I reset the flash-based
  BBT?>>)
	

[[new_badblocks]]
== How are new bad blocks discovered and marked?

Besides initial bad blocks marked at factory production time, a NAND chip may
develop bad blocks over time due to wear. These may be detected in different
contexts and may be handled differently in, for instance, <<cfe_badblocks,BOLT>>
and <<linux_badblocks,Linux>>.

*BOLT*: New bad blocks may be marked when a program operation
fails. New bad blocks are marked in the OOB region of the affected
block. As BOLT cannot understand Linux's bad block table format, this
can cause incompatibility with Linux.

*Linux*: New bad blocks can be discovered as a result of failed write
or erase operations or when a complex filesystem layer such as UBI
notices too many accumulated bitflips which cannot be resolved by
"scrubbing." When flash-based BBT is disabled, a new bad block is
marked only in the bad block's OOB region. When flash-based BBT is
enabled, the new bad block is marked in the on-flash BBT region. As of
STB Linux 2.6.37-2.9, Linux will mark new bad blocks in *both* the
flash-based BBT and the OOB bad block marker by default. This allows
BOLT to recognize bad blocks marked from Linux. Note that the reverse
is not true; when using flash-based BBT, Linux may not recognize new
bad blocks marked by BOLT and may treat them as good blocks until they
are marked in Linux's BBT.

See also the following, regarding bad blocks:

- <<cfe_badblocks,How does BOLT handle bad blocks?>>
- <<linux_badblocks,How does Linux handle bad blocks?>>
- http://www.linux-mtd.infradead.org/doc/ubi.html#L_torturing[UBI: marking eraseblocks as bad]


[[nand_support]]
== Is my NAND chip supported?

Broadcom does not form an official list of supported NAND flash. However, we do
get a significant amount of test coverage on a few specific NAND: the NAND flash
found on our reference boards. Generally, ONFI-compliant NAND are supported, as
well as most SLC NAND with 2KB page size that follow standard ID encoding
practices, such as those found in the datasheet for Samsung K9F2G08U0C.
Specifically, the following have received wide test coverage:

- (MLC) Micron MT29F32G08CBACA
- (SLC) Samsung K9F2G08U0C

For other flash, please direct questions--with part number and datasheet
provided--to our engineering staff. Also note that for best results,
engineers prefer to have a sample chip to test against.


[[erase_badblocks]]
== Why shouldn't I erase bad blocks?

In almost all cases, blocks that are already marked bad should not be erased,
so that existing bad-block mark indicators are preserved. There are a few
reasons for this, as follows:

NAND manufacturers have sophisticated test systems on their production lines to
check devices for bad blocks. The process includes testing over voltage and
temperature. They are able to find marginally-bad blocks that erase/program
fine at room temperature and nominal voltage, but would fail to erase or
program in a temperature or voltage corner - or they could quickly turn into a
bad block after just a few erase/program cycles. In other words, the
manufacturers' ability to identify bad blocks is much better than software
erase/write cycles at nominal conditions.

Note that Linux, BOLT, Broadband Studio, <a href="#Webflasher">Webflasher</a>,
and any other reasonable system that works with NAND flash all have their own
protections to prevent erasure of bad blocks, by checking for bad block markers
in the OOB region and/or building bad block tables, but these protections
occasionally have backdoors to allow for special development needs. Please think
twice before indiscriminately erasing bad blocks.

IMPORTANT: Really, please do not erase bad blocks!


[[linux_override]]
== Why does Linux override my NAND configuration?

This is one of the most common types of issues we see in customer projects
using NAND. Sometimes, a message like the following will turn up in the Linux
boot log:

----
brcmnand brcmnand.0: overriding bootloader settings on CS1
brcmnand brcmnand.0: was: 16MiB total, 16KiB blocks, 512B pages, 16B OOB, 8-bit, BCH-4
brcmnand brcmnand.0: now: 4096MiB total, 1024KiB blocks, 4KiB pages, 27B OOB, 8-bit, BCH-24 (1KiB sector)
----

This message should alert the developer that the bootloader did not configure
NAND correctly, and so Linux is providing its own configuration. This
misconfiguration can have important ramifications which, if ignored, can cause
various problems, including ECC errors, an inability for Linux to read data
written by BOLT, and more. Any time these messages appear in a log, no guarantees
can be made about ANY future NAND activity.

On a typical platform, it is the responsibility of the bootloader (i.e., BOLT)
to provide an initial working configuration for any NAND flash present on the
board. That way, the bootloader can perform basic operations on NAND--such
as loading or flashing a kernel--effectively, while later passing control
off to Linux. However, CFE historically has often failed to configure NAND
correctly, especially during early development, and it never compensated for an
incorrect `boot_shape` strap. BOLT improves this situation through more
accurate detection and configuration logic.

Still, any misconfiguration mismatch between BOLT and Linux can lead
to problems--subtle or otherwise--and so our Linux driver, with the
help of sophisticated NAND detection routines provided by the MTD
subsystem, chooses to validate any bootloader-provided settings before
accepting them. At boot-time, it detects the NAND either via ONFI
parameter parsing or decoding the NAND chip ID (via `READID` command)
checks a number of different NAND configuration parameters (found in
the appropriate `NAND_CONFIG` and `NAND_ACC_CONTROL` registers), and a
mismatch in any one of them may cause the driver to invalidate the
entire bootloader configuration and replace it with its own.

So, to provide a correct configuration to Linux and to avoid the need for Linux
to override your settings, please check your NAND datasheet and ensure that the
bootloader is configuring all of the following settings correctly:

- total device size
- block size
- page size
- out-of-band (OOB) / spare area size
- bus width (x8 or x16)
- `BLK_ADR_BYTES / COL_ADR_BYTES / FUL_ADR_BYTES` (see `NAND_CONFIG`
  register in RDB)

If you still see the "overriding" message after correcting all of these values,
then there may be a bug in the Linux NAND detection routines. In this case,
please file a bug report with a full boot log, NAND part number, and NAND
datasheet provided.


[[ubiroot]]
== What happened to `ubiroot`?

On Linux 3.3 and earlier, our STB Linux platforms provided a shortcut
boot parameter `ubiroot` for booting with a UBIFS root filesystem.
This shortcut is no longer available as of Linux 3.8. To get the
correct boot parameters for your board, please run the `stbutil`
utility (in Linux); upon completion, it will provide you with your
boot arguments.

In the future, we hope to implement a new installation procedure that
can simplify this process.


[[Webflasher]]
== Webflasher

The Webflasher project is a Broadcom-internal project intended for simple,
reliable handling of many aspects related to flash on STB products. It can
handle writing images, erasing, or total (unsafe) erasing of most NAND flash as
well as SPI-NOR flash.
Please note that (as of June 2015) Webflasher is only supported for
Broadcom-internal use. Customers will still have to utilize Broadband Studio
for basic flashing needs.

To use Webflasher, you need an BCM9EJTAGPRB probe fitted with a
Webflasher firmware image and connected to the Broadcom network. Then
you can perform flashing over network via the Webflasher main page:

- http://webflash.broadcom.com/[Webflasher main site]
- http://twiki-01.broadcom.com/bin/view/Linux/EjtagDebugger#How_to_get_my_probe[How to get an EJTAG probe]
- http://twiki-01.broadcom.com/bin/view/Linux/EjtagDevelopment[EJTAG probe development Twiki]

[[Ref]]
== More references

For further reading on the Linux MTD, NAND, JFFS2, UBI, and UBIFS
filesystems and subsystems, see the documentation and FAQs at
http://linux-mtd.infradead.org/.

